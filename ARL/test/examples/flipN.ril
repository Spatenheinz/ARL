begin main
includeC "A = 0;\n";
// initialize hash codes
hashA += 366001;
hashB += 827927;
hashC += 593041;
hashT += hashA;
// heap size setup
b += 8; // segment size
b1 += b - 1;
hsize += 1<<15;
hsize += b1; // number of nodes = 2^m + b - 1
hsizeB += hsize << 2;
hsizeB += hsize << 2;
hsizeB += hsize << 2; // number of bytes
H += 4800; // heap start
endH += hsizeB + H; // heap end
lastH += endH - 12; // address of last node in heap
mask += 4<<15;
mask -= 4;
segSize += b1<<2;
segSize += b1<<2;
segSize += b1<<2;
stackP += endH;
stackP += 64;
call initialise;
call build;

call flip;

includeC "printf(\"max refs = %d\\n\",A);";
assert z == 0;
z += H;
dump1 <-- H != z;
M[z] > 0 --> used1;
y += 1;
used1 <-- M[z] > 0;
z += 12;
z < endH --> dump1;
test y "%d,"
end main


begin initialise
consA += 2;
consD += 2;
call cons;
nilnil <-> consP
end initialise


begin build
consD += 2;
consA += 21;
call cons;
consP <-> consD;
consA += 19;
call cons;
consP <-> consD;
consA += 17;
call cons;
consP <-> consD;
consA += 15;
call cons;
consP <-> consD;
consA += 13;
call cons;
consP <-> consD;
consA += 11;
call cons;
consP <-> consD;
consA += 9;
call cons;
consP <-> consD;
consA += 7;
call cons;
consP <-> consD;
consA += 5;
call cons;
consP <-> consD;
consA += 3;
call cons;
consP <-> consD;
consD <-> A
end build


begin flip
skip
--> flip_entry_1
flip_exit_1 <--
skip
end flip

flip_entry_1 <--
// input of rule1
A & 3 --> l_rflip1;
A <-> consP;
uncall cons;
t1l_r <-> consA;
t2l_r <-> consD;
l <-> t1l_r;
t1l_r != 0 --> l_rflip2;
r <-> t2l_r;
t2l_r == 0 --> l_rflip3;
l_rflip2 <-- t1l_r != 0;
l <-> t1l_r;
t1l_r <-> consA;
t2l_r <-> consD;
call cons;
A <-> consP;
l_rflip3 <-- A == 0;
l_rflip1 <-- A & 3;
A != 0 --> flip_entry_2;
//def starts here
l <-> A;
r <-> M[stackP];
stackP += 4;
call flip;
stackP -= 4;
r <-> M[stackP];
fl <-> A;
assert A == 0;
r <-> A;
fl <-> M[stackP];
stackP += 4;
call flip;
stackP -= 4;
fl <-> M[stackP];
fr <-> A;
assert A == 0;
flip_exit_2 <-- A != 0;
//res starts here
A & 3 --> inv_fr_flflip8;
A == 0 --> inv_fr_flflip10;
A <-> consP;
uncall cons;
inv_t_flip8fr_fl <-> consA;
inv_t_flip9fr_fl <-> consD;
fr <-> inv_t_flip8fr_fl;
inv_t_flip8fr_fl != 0 --> inv_fr_flflip9;
inv_fr_flflip10 <-- inv_t_flip9fr_fl == 0;
fl <-> inv_t_flip9fr_fl;
inv_fr_flflip9 <-- inv_t_flip8fr_fl != 0;
fr <-> inv_t_flip8fr_fl;
inv_t_flip8fr_fl <-> consA;
inv_t_flip9fr_fl <-> consD;
call cons;
A <-> consP;
inv_fr_flflip8 <-- A & 3;
skip
--> flip_exit_1


flip_entry_2 <--
// input of rule2
assert x == 0;
A & 3 --> l_rflip23;
A <-> consP;
uncall cons;
t23l_r <-> consA;
t24l_r <-> consD;
l <-> t23l_r;
t23l_r != 0 --> l_rflip24;
r <-> t24l_r;
t24l_r == 0 --> l_rflip25;
l_rflip24 <-- t23l_r != 0;
l <-> t23l_r;
t23l_r <-> consA;
t24l_r <-> consD;
call cons;
A <-> consP;
l_rflip25 <-- A == 0;
l_rflip23 <-- A & 3;
x += A;
A & 3 --> inv_l_rflip30;
A == 0 --> inv_l_rflip32;
A <-> consP;
uncall cons;
inv_t_flip30l_r <-> consA;
inv_t_flip31l_r <-> consD;
l <-> inv_t_flip30l_r;
inv_t_flip30l_r != 0 --> inv_l_rflip31;
inv_l_rflip32 <-- inv_t_flip31l_r == 0;
inv_t_flip31l_r != 0 --> flip34;
r <-> copyP;
call copy;
r <-> copyP;
inv_t_flip31l_r <-> copyQ;
flip34 <-- inv_t_flip31l_r != r;
inv_l_rflip31 <-- inv_t_flip30l_r != 0;
inv_t_flip30l_r != 0 --> flip33;
l <-> copyP;
call copy;
l <-> copyP;
inv_t_flip30l_r <-> copyQ;
flip33 <-- inv_t_flip30l_r != l;
inv_t_flip30l_r <-> consA;
inv_t_flip31l_r <-> consD;
call cons;
A <-> consP;
inv_l_rflip30 <-- A & 3;
A -= x;
A != 0 --> flip_entry_3;
//def starts here

flip_exit_3 <-- A != 0;
//res starts here
A += x;
A & 3 --> fr_flflip37;
A <-> consP;
uncall cons;
t37fr_fl <-> consA;
t38fr_fl <-> consD;
fr <-> t37fr_fl;
t37fr_fl != 0 --> fr_flflip38;
fl <-> t38fr_fl;
t38fr_fl == 0 --> fr_flflip39;
fr_flflip38 <-- t37fr_fl != 0;
fr <-> t37fr_fl;
t37fr_fl <-> consA;
t38fr_fl <-> consD;
call cons;
A <-> consP;
fr_flflip39 <-- A == 0;
fr_flflip37 <-- A & 3;
x -= A;
A & 3 --> inv_fr_flflip44;
A == 0 --> inv_fr_flflip46;
A <-> consP;
uncall cons;
inv_t_flip44fr_fl <-> consA;
inv_t_flip45fr_fl <-> consD;
fr <-> inv_t_flip44fr_fl;
inv_t_flip44fr_fl != 0 --> inv_fr_flflip45;
inv_fr_flflip46 <-- inv_t_flip45fr_fl == 0;
inv_t_flip45fr_fl != 0 --> flip48;
fl <-> copyP;
call copy;
fl <-> copyP;
inv_t_flip45fr_fl <-> copyQ;
flip48 <-- inv_t_flip45fr_fl != fl;
inv_fr_flflip45 <-- inv_t_flip44fr_fl != 0;
inv_t_flip44fr_fl != 0 --> flip47;
fr <-> copyP;
call copy;
fr <-> copyP;
inv_t_flip44fr_fl <-> copyQ;
flip47 <-- inv_t_flip44fr_fl != fr;
inv_t_flip44fr_fl <-> consA;
inv_t_flip45fr_fl <-> consD;
call cons;
A <-> consP;
inv_fr_flflip44 <-- A & 3;
assert x == 0;
skip
--> flip_exit_2

flip_entry_3 <--
assert A != A
--> flip_exit_3


begin copy
assert copyP > 0 && copyQ == 0;
copyP !& 3 --> copySymbol;
M[copyP] += 1;
ttt += M[copyP];
includeC "if (A < var_ttt) A = var_ttt;";
ttt -= M[copyP];
copySymbol <-- copyP !& 3;
copyQ += copyP;
assert copyP > 0 && copyQ == copyP
end copy


begin fields
assert fieldsP > 0 && fieldsA == 0 && fieldsD == 0;
fieldsP += 4;
fieldsA += M[fieldsP];
fieldsA !& 3 --> fields1;
M[fieldsA] += 1;
fields1 <-- fieldsA !& 3;
fieldsP += 4;
fieldsD += M[fieldsP];
fieldsD !& 3 --> fields2;
M[fieldsD] += 1;
fields2 <-- fieldsD !& 3;
fieldsP -= 8;
assert fieldsP > 0 && fieldsA > 0 && fieldsD > 0
end fields


//The rest of the file is cons
begin cons
assert consA != 0;
assert consD != 0;
assert consP == 0;
assert hashV == 0;
assert segEnd == 0;
call hash;
segEnd += hashV + segSize;
consP += hashV;
consSearchSame <-- consP > hashV;
M[consP] == 0 --> consNext;
consP += 4;
M[consP] != consA --> consNotA;
consP += 4;
M[consP] == consD --> consFoundSame;
consP -= 4;
consNotA <-- M[consP] != consA;
consP -= 4;
consNext <-- M[consP] == 0;
consP += 12;
consP <= segEnd --> consSearchSame;
consSearchEmpty <-- consP <= segEnd;
consP -= 12;
consP < hashV --> consFail;
M[consP] != 0 --> consSearchEmpty;
segEnd -= hashV + segSize;
uncall hash;
M[consP] += 1;
consP += 4;
consA <-> M[consP];
consP += 4;
consD <-> M[consP];
consP -= 8;
consEnd <-- M[consP] > 1;
assert consP !& 3 && consP >= H && consA == 0 && consD == 0;
assert hashV == 0 && segEnd == 0;
failedCons <-- failed > 0 // return point for fail handler
end cons

consFoundSame <--
segEnd -= hashV + segSize; // was 60
uncall hash;
consD < H --> consSymbolD;
M[consD] -= 1;
consSymbolD <-- consD < H;
consD -= M[consP];
consP -= 4;
consA < H --> consSymbolA;
M[consA] -= 1;
consSymbolA <-- consA < H;
consA -= M[consP];
consP -= 4;
M[consP] += 1;
ttt += M[consP];
includeC "if (A < var_ttt) A = var_ttt;";
ttt -= M[consP]
--> consEnd
consFail <--
failed += 1;
assert z == 0;
z += H;
dump <-- H != z;
M[z] > 0 --> used;
y += 1;
used <-- M[z] > 0;
z += 12;
z < endH --> dump;
test y " free nodes: %d,"
--> failedCons // jump to end of cons procedure

begin hash
assert hashV == 0 && hashT ==  366001;
hashT ^= consA << 7;
hashT += consA >> 1;
hashT ^= consD << 5;
hashT += consD >> 3;
hashV += hashT & mask;
hashV += hashT & mask;
hashV += hashT & mask;
hashV += H
end hash